Алгоритмы сортировки
Блочная (корзинная) сортировка
Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. После этого каждая корзина сортируется отдельно (либо тем же методом рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив.
Принцип работы:
1. Определяется количество корзин (например, по диапазону значений элементов):
   buckets_count = len(arr)
2. Каждый элемент помещается в корзину согласно функции распределения:
   for num in arr:
        normalized_value = num / max(arr)
        bucket_idx = int(normalized_value * (buckets_count - 1))
        buckets[bucket_idx].append(num)
3. Содержимое каждой корзины сортируется индивидуально.
    sorted_buckets = []
    for bucket in buckets:
        sorted_bucket = sorted(bucket)
        sorted_buckets.extend(sorted_bucket)
4. Корзины соединяются в порядке увеличения диапазона.
   return sorted_buckets
Временная сложность: O(N)
Пояснение:
Сложность вычисляется как O(N+k), где N — количество элементов, а k — количество корзин.В общем случае k близко к N, поэтому время работы приближенно к O(N).
Особенности:
Эффективна для равномерно распределённых числовых данных и может достигать линейной асимптотики O(n), если размер корзин выбран удачно. Однако эффективность сильно падает при неравномерном распределении данных.

Блинная сортировка
Определение: Блинная сортировка (pancake sort) — это метод, основанный на операции переворота (reversal) части массива. В отличие от большинства алгоритмов, которые обменивают соседние элементы или выбирают опорные точки, здесь единственная разрешённая операция — переворот префикса массива до выбранного индекса.
Принцип работы:
1. Найти максимальный элемент в неотсортированной части массива.
    max_idx = find_max(arr, current_size)
2. Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот элемент оказался первым.
   flip(arr, max_idx)
3. Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце.
   flip(arr, current_size - 1)
4. Повторить процесс для оставшейся неотсортированной части массива.
   while current_size > 1:
Временная сложность: O(N^2)
Пояснение:
Дело в том, что на каждом шаге мы обращаемся ко всей оставшейся части массива, и каждый переворот занимает линейное время.
Особенности:
Сложность алгоритма — O(n^2). Он интересен теоретически и используется как пример нестандартных методов сортировки.

Сортировка бусинами (гравитационная)
Определение: Сортировка бусинами (bead sort), также известная как гравитационная сортировка, моделирует естественное поведение бусин, падающих вниз под действием гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл Диннин в 2002 году.
Принцип работы:
1. Каждый элемент массива представляется в виде горизонтального ряда бусин, количество которых соответствует его значению.
   [True if j < val else False for j in range(max(arr))]
2. Бусины располагаются на «стержнях» (как на абаке).
   grid = [[True if j < val else False for j in range(max(arr))] for val in arr]
3. Под действием «гравитации» бусины падают вниз.
   for col in range(len(grid[0])):
        count = sum(row[col] for row in grid)
        for row in range(count):
            grid[row][col] = True
        for row in range(count, len(grid)):
            grid[row][col] = False
4. После оседания бусин строки считываются сверху вниз — получается отсортированный массив.
    sorted_arr = [sum(col) for col in zip(*grid)]
Временная сложность: O(N)
Пояснение:
Это связано с созданием сетки и последующим прохождением по каждому столбцу и ряду.
Особенности:
Алгоритм применим только для неотрицательных целых чисел. Теоретическая сложность — O(n), но практическая — выше из-за ограничения на диапазон и реализацию.

Алгоритмы поиска
Поиск скачками (Jump Search)
Определение:
Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного диапазона.
Принцип работы:
1. Делится массив на блоки длины m=n.
   while arr[min(step, n)-1] < target:
        prev = step                     
        step += int(math.sqrt(n))       
        if prev >= n:                   
            return -1
2. Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный искомому.
   while arr[prev] < target:
        prev += 1
3. Если найденный элемент больше искомого, выполняется линейный поиск в предыдущем блоке.
   prev = step
Временная сложность: O(N^(1/2))-O(N)
Пояснение:
Это достигается за счёт оптимального выбора шага поиска (квадратный корень от размера массива). Такой выбор позволяет минимизировать количество прыжков и снизить влияние линейного поиска в блоках. Но из-за наличия элемента линейного поиска про выборе неоптимальных шагов может возрастать до линейной зависимости.
Особенности:
В среднем сложность поиска O(n).
Оптимален, когда данные отсортированы и доступ к элементам осуществляется за постоянное время.

Экспоненциальный поиск (Exponential Search)
Определение:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя быстро определить диапазон, в котором может находиться искомое значение, а затем применяет двоичный поиск в этом диапазоне.
Принцип работы:
1. Проверяется первый элемент массива.
   if arr[0] == target:
        return 0
2. Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д., пока не будет найден элемент, больше или равный искомому.
    while i < len(arr) and arr[i] <= target:
        i *= 2
3. На найденном диапазоне выполняется бинарный поиск.
   while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
Временная сложность: O(log⁡ N)
Пояснение:
Это достигается за счёт комбинации удвоения шага и бинарного поиска.
Особенности:
Сложность O(log⁡n). Эффективен при поиске в очень больших отсортированных массивах с неизвестным размером или частичным доступом.
Тернарный поиск (Ternary Search)
Определение:
Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или экстремум функции (в зависимости от задачи).
Принцип работы (для массива):
1. Делится диапазон индексов на три части.
   third = (right - left) / 3
2. Сравнивается искомый элемент с элементами на двух разделительных границах.
   if func(left_third) < func(right_third):
3. Если совпадение не найдено, алгоритм повторяется рекурсивно в одной из трети массива, где может находиться искомое значение.
   return (left + right) / 2
Временная сложность: O(log⁡ N)
Пояснение:
Это достигается за счёт постоянного деления интервала на три части, что существенно сокращает время поиска.
Особенности:
Сложность также O(log⁡n), но число сравнений на шаг выше, чем в двоичном поиске.
Помимо массивов, тернарный поиск часто используется для нахождения минимума или максимума на унимодальных функциях.
