Алгоритм сортировки выбором (Selection Sort)
•	Определение:
Сортировка выбором (Selection Sort) — алгоритм, на каждом шаге которого находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве.
•	Анализ:
o	Внешний цикл: Мы проходим по массиву слева направо. Для каждого элемента мы считаем, что, начиная с текущей позиции, остальная часть массива ещё не отсортирована. Например, на первой итерации внешний цикл выбирает первую позицию массива.
o	Минимальный элемент: Во внутреннем цикле ищем минимальное значение среди всех последующих элементов справа от выбранной позиции внешнего цикла. Это делается путем последовательного сравнения каждого последующего элемента с текущим минимальным кандидатом.
o	Обмен элементами: Когда внутренний цикл заканчивает свою работу, найденный минимальный элемент меняется местами с начальным элементом рассматриваемого диапазона (текущим положением внешнего цикла). Таким образом, самый маленький элемент перемещается в начало неотсортированной части массива.
o	Продолжение процесса: Затем процесс повторяется снова и снова, пока весь массив не окажется отсортированным.
•	Временная сложность: O(n^2)
•	Пояснение:
Основная функция сортировки содержит в себе два вложенных цикла, каждый из которых в худшем случае проходит по n элементам. Таким образом алгоритм n раз проходиться по n элементам, отсюда возникает квадратичная зависимостью.
Алгоритм сортировки обменом (пузырьком) (Bubble Sort) 
•	Определение:
Сортировка обменом (пузырьком) (Bubble Sort) — алгоритм, который проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке, до тех пор, пока список не будет полностью отсортирован.
• Анализ:
o Определение длины массива: Используется стандартная функция len() для вычисления количества элементов в списке.
o Внешний цикл: Первый цикл запускает необходимое количество проходов по списку. Количество проходов равно длине списка минус единица, так как последний элемент уже автоматически займёт своё место после предыдущих проходов.
o Внутренний цикл: Этот цикл занимается непосредственной работой по проверке и возможному обмену соседних элементов. Из-за уменьшения числа необработанных элементов после каждого прохода, внутренний цикл сокращается на единицу на каждом витке внешнего цикла.
• Временная сложность: O(n^2)
• Пояснение:
Основная функция сортировки содержит в себе 2 вложенных цикла, где внешний проходится по n элементам, количество итераций внутреннего каждый проход уменьшается на 1, таким образом количество выполняемых сравнений и, в худшем случае, перестановок равно (n-1)n/2, что и даёт квадратичную зависимость.
Алгоритм сортировки вставками (Insertion Sort)
• Определение:
Сортировка вставками (Insertion Sort) - алгоритм основывающийся на постепенном построении отсортированной части массива путём вставки новых элементов на нужное место в уже отсортированную последовательность.
• Анализ:
Мы берём второй элемент массива и смотрим, куда его поместить в уже отсортированную левую часть. Затем переходим к третьему элементу и повторяем операцию, и так далее, пока весь массив не будет отсортирован.
•	Временная сложность: O(n^2)
• Пояснение:
Основная функция сортировки содержит в себе 2 вложенных цикла, где внешний проходится по n элементам, количество итераций внутреннего каждый проход увеличивается на 1, таким образом количество выполняемых сравнений и, в худшем случае, перестановок равно (n-1)n/2, что и даёт квадратичную зависимость.
Алгоритм сортировки слиянием (Merge Sort)
• Определение:
Cортировка слиянием (Merge Sort) - алгоритм, который использует принцип "разделяй и властвуй": массив делится на две половины, каждая половина рекурсивно сортируется отдельно, а потом обе половинки объединяются обратно в общий отсортированный массив.
• Анализ:
o этапы:
1. Разделить массив на две равные части.
2. Отдельно отсортировать каждую часть.
3. Соединить (слить) отсортированные части вместе.
o Этот процесс повторяется рекурсивно, пока каждый фрагмент не сократится до одиночных элементов, после чего они сливаются обратно в отсортированный массив.
•	Временная сложность: O(n log n)
• Пояснение:
o Подразделение массива: Каждое деление массива пополам происходит за константное время O(1).
o Рекурсивные вызовы: Алгоритм рекурсивно вызывает себя дважды на каждой глубине дерева рекурсий, причем глубина достигает log2(N). Следовательно, дерево рекурсий растет по высоте логарифмически.
o Объединение: На каждом уровне рекурсии объединение двух отсортированных массивов занимает линейное время O(N), так как необходимо пройти по обоим подмассивам и записать элементы в результирующий массив.
Алгоритм сортировки Шелла (Shellsort)
• Определение:
Cортировка Шелла (Shellsort) представляет собой усовершенствованную версию сортировки вставками. Идея метода заключается в том, чтобы сначала сравнивать элементы, находящиеся далеко друг от друга, а затем уменьшать интервал сравнения, постепенно приближаясь к обычному алгоритму сортировки вставками.
• Анализ:
o Вместо того чтобы сразу сравнивать соседние элементы, вначале сравниваются элементы, расположенные на некотором удалении друг от друга (определённом расстоянием gap).
o Значение расстояния (промежутка) постепенно уменьшается, делая процесс похожим на обычную сортировку вставками.
o Чем меньше становится промежуток (gap), тем ближе элементы становятся к своим правильным местам в отсортированном массиве.
•	Временная сложность: O(n^2) - О(n log n)
• Пояснение:
Так как алгоритм основан на 3 вложеных циклах, каждый из которых проходиться по некоторому количеству элементов не превышающему gap, которое меньше n и на каждой итерации внешнего цикла gap уменьшается в двое, что позволяет сильно ускорить процесс и добиться зависимости O(n log n), но в худшем случае может и привести к зависимости O(n^2)
Алгоритм быстрой сортировки (Quick Sort)
• Определение:
быстрая сортировка (Quicksort) — один из наиболее популярных и эффективных алгоритмов сортировки, использующих подход "разделяй и властвуй". Основная идея алгоритма заключается в выборе опорного элемента (pivot), разделении массива на две части (элементы меньше pivot и элементы больше pivot), и рекурсивной сортировке этих частей.
• Анализ:
o Выбор опорного элемента (pivot): Это ключевой этап. Опорный элемент выбирается из массива, чаще всего это среднее или произвольное значение.
o Разбиение массива: Все элементы массива распределяются на две группы: меньшие и большие опорного элемента.
o Рекурсивная сортировка: Каждая группа рекурсивно сортируется теми же методами, пока весь массив не станет отсортированным.
•	Временная сложность: O(n^2) - О(n log n)
• Пояснение:
o В подавляющем большинстве случаев Quicksort ведёт себя превосходно, так как на каждом шаге массив делится примерно пополам.
o O(n^2) возникает, если постоянно выбирается неудачный опорный элемент (например, наименьший или наибольший элемент массива). В таком случае разделения фактически не происходят, и мы вынуждены многократно обрабатывать почти всю область массива.
Алгоритм пирамидальной сортировки (Heap Sort)
• Определение:
Пирамидальная сортировка (Heap Sort) — это метод сортировки сравнением, основанный на такой структуре данных как двоичная куча.
• Анализ:
o Постройка кучи (heapify) — преобразование массива в двоичную кучу (получаем так называемую max-кучу, где корень всегда больше детей).
o Сортирующее извлечение максимального элемента — удаление корня (самого большого элемента) и перестроение кучи, пока массив не будет отсортирован.
•	Временная сложность: O(n log n)
• Пояснение:
o Постройка кучи (heapification): Это выполняется за O(n), так как каждое обновление узла занимает постоянное время, а количество уровней в куче логарифмическое.
o Фаза сортировки: Она выполняется за O(n log n), так как удаление каждого элемента (включая его перестройку) требует O(log n) операций, а таких действий выполняется n раз.
Алгоритм линейного поиска
• Определение:
Линейный поиск — это простейший алгоритм поиска элемента в коллекции (списке, массиве и т.п.). Он последовательно перебирает элементы, пока не найдет искомый объект или не закончит осмотр всей коллекции.
• Анализ:
o Принятие входных данных: Пользователь передает два аргумента функции linear_search: список (arr) и целевой элемент (target), который нужно найти.
o Построение цикла: Происходит прямой проход по каждому элементу списка. Это означает, что мы последовательно проверяем каждый элемент, начиная с первого и заканчивая последним.
o Проверка на совпадение: На каждой итерации проверяется, совпадает ли текущий элемент с искомым. Если совпал, мы немедленно возвращаем индекс этого элемента.
o Завершение поиска: Если мы дошли до конца списка и не нашли нужный элемент, возвращается специальный маркер None, сигнализирующий о том, что элемент не обнаружен.
•	Временная сложность: O(n)
• Пояснение:
Алгоритм просто проходит подряд по всем элементам списка 1 раз, пока не найдет искомый элемент, тоесть в худшем случае n раз выполняет проверку элемента.
Алгоритм бинарного поиска (Binary Search)
• Определение:
Бинарный поиск (Binary Search) — это эффективный метод поиска элемента в отсортированном массиве или списке. Бинарный поиск работает по принципу исключения половины области поиска на каждом шаге, что делает его намного быстрее, чем линейный поиск.
• Анализ:
o Алгоритм начинает с предположения, что массив отсортирован.
o Мы выбираем средний элемент массива и сравниваем его с искомым значением.
o Если средний элемент равен искомому, задача решена.
o Если искомое значение меньше среднего элемента, то дальнейшее исследование ведётся только в левой половине массива.
o Если искомое значение больше среднего элемента, то исследуется только правая половина массива.
o Эти шаги повторяются в цикле, пока не найдём искомый элемент или пока область поиска не сузится до нуля.
•	Временная сложность: O(log n)
• Пояснение:
На каждом шаге алгоритм делит область поиска пополам, и количество возможных вариантов для рассмотрения уменьшается экспоненциально.
Алгоритм интерполирующего поиск (Interpolation Search)
• Определение:
Интерполирующий поиск (Interpolation Search) — это модификация бинарного поиска, предназначенная для ускоренного поиска в отсортированных массивах, преимущественно с равномерно распределёнными элементами. Интерполирующий поиск улучшает классический бинарный поиск за счёт учёта распределения элементов и приблизительного положения искомого элемента.
• Анализ:
Класс и функция interpolationSearch:

public class InterpolationSearch {
    public static int interpolationSearch(int[] arr, int target) {
Класс называется InterpolationSearch, содержащий статический метод interpolationSearch, который принимает два аргумента: отсортированный массив (arr) и искомое значение (target).
Установка границ поиска:

int low = 0;                   // Нижний индекс
        int high = arr.length - 1;     // Верхний индекс
Низкая граница (low) установлена в самое начало массива (индекс 0).
Высокая граница (high) — это последняя позиция массива (размер массива минус 1).
Основное тело поиска:

while ((low <= high) && (target >= arr[low]) && (target <= arr[high])) {
Основное условие продолжения поиска:  
Границы не пересеклись (low <= high).  
Искомый элемент находится в диапазоне между крайними элементами массива (target >= arr[low] и target <= arr[high]).
Вычисление вероятного индекса:

int pos = low + (((target - arr[low]) * (high - low)) / (arr[high] - arr[low]));
Это ключевая формула интерполирующего поиска. Она рассчитывает позицию элемента, исходя из предположения равномерного распределения элементов в массиве.  
Формула предполагает, что разница между верхним и нижним пределами отражает отношение разницы между target и минимальным элементом (arr[low]) к общей ширине диапазона (arr[high] - arr[low]).
Проверка на попадание:

if (arr[pos] == target) {
                return pos;
            }
Если найденный элемент (arr[pos]) равен искомому, сразу возвращаем его индекс.
Регулирование границ поиска:

if (arr[pos] < target) {
                low = pos + 1;
            } else {
                high = pos - 1;
            }
Если текущий элемент меньше искомого, мы сужаем поиск в правую сторону (low = pos + 1).  
Если текущий элемент больше искомого, мы сужаем поиск в левую сторону (high = pos - 1).
Завершение поиска: Если цикл завершился, но элемент не найден, возвращается -1, что означает отсутствие элемента в массиве.
